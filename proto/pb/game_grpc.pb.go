// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: game.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LoginService_Register_FullMethodName     = "/pb.LoginService/Register"
	LoginService_Login_FullMethodName        = "/pb.LoginService/Login"
	LoginService_Reconnect_FullMethodName    = "/pb.LoginService/Reconnect"
	LoginService_KickPlayer_FullMethodName   = "/pb.LoginService/KickPlayer"
	LoginService_GetQueueInfo_FullMethodName = "/pb.LoginService/GetQueueInfo"
)

// LoginServiceClient is the client API for LoginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 登录相关
type LoginServiceClient interface {
	// 注册
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Reconnect(ctx context.Context, in *ReconnectRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	KickPlayer(ctx context.Context, in *KickPlayerRequest, opts ...grpc.CallOption) (*CommonResponse, error)
	GetQueueInfo(ctx context.Context, in *QueueInfoRequest, opts ...grpc.CallOption) (*QueueInfoResponse, error)
}

type loginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoginServiceClient(cc grpc.ClientConnInterface) LoginServiceClient {
	return &loginServiceClient{cc}
}

func (c *loginServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, LoginService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, LoginService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) Reconnect(ctx context.Context, in *ReconnectRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, LoginService_Reconnect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) KickPlayer(ctx context.Context, in *KickPlayerRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, LoginService_KickPlayer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) GetQueueInfo(ctx context.Context, in *QueueInfoRequest, opts ...grpc.CallOption) (*QueueInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueueInfoResponse)
	err := c.cc.Invoke(ctx, LoginService_GetQueueInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoginServiceServer is the server API for LoginService service.
// All implementations must embed UnimplementedLoginServiceServer
// for forward compatibility.
//
// 登录相关
type LoginServiceServer interface {
	// 注册
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Reconnect(context.Context, *ReconnectRequest) (*LoginResponse, error)
	KickPlayer(context.Context, *KickPlayerRequest) (*CommonResponse, error)
	GetQueueInfo(context.Context, *QueueInfoRequest) (*QueueInfoResponse, error)
	mustEmbedUnimplementedLoginServiceServer()
}

// UnimplementedLoginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLoginServiceServer struct{}

func (UnimplementedLoginServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedLoginServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedLoginServiceServer) Reconnect(context.Context, *ReconnectRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reconnect not implemented")
}
func (UnimplementedLoginServiceServer) KickPlayer(context.Context, *KickPlayerRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KickPlayer not implemented")
}
func (UnimplementedLoginServiceServer) GetQueueInfo(context.Context, *QueueInfoRequest) (*QueueInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueueInfo not implemented")
}
func (UnimplementedLoginServiceServer) mustEmbedUnimplementedLoginServiceServer() {}
func (UnimplementedLoginServiceServer) testEmbeddedByValue()                      {}

// UnsafeLoginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoginServiceServer will
// result in compilation errors.
type UnsafeLoginServiceServer interface {
	mustEmbedUnimplementedLoginServiceServer()
}

func RegisterLoginServiceServer(s grpc.ServiceRegistrar, srv LoginServiceServer) {
	// If the following call pancis, it indicates UnimplementedLoginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LoginService_ServiceDesc, srv)
}

func _LoginService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_Reconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).Reconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_Reconnect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).Reconnect(ctx, req.(*ReconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_KickPlayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KickPlayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).KickPlayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_KickPlayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).KickPlayer(ctx, req.(*KickPlayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_GetQueueInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).GetQueueInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_GetQueueInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).GetQueueInfo(ctx, req.(*QueueInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LoginService_ServiceDesc is the grpc.ServiceDesc for LoginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.LoginService",
	HandlerType: (*LoginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _LoginService_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _LoginService_Login_Handler,
		},
		{
			MethodName: "Reconnect",
			Handler:    _LoginService_Reconnect_Handler,
		},
		{
			MethodName: "KickPlayer",
			Handler:    _LoginService_KickPlayer_Handler,
		},
		{
			MethodName: "GetQueueInfo",
			Handler:    _LoginService_GetQueueInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	BattleService_CreateRoom_FullMethodName       = "/pb.BattleService/CreateRoom"
	BattleService_JoinRoom_FullMethodName         = "/pb.BattleService/JoinRoom"
	BattleService_LeaveRoom_FullMethodName        = "/pb.BattleService/LeaveRoom"
	BattleService_StartBattle_FullMethodName      = "/pb.BattleService/StartBattle"
	BattleService_EndBattle_FullMethodName        = "/pb.BattleService/EndBattle"
	BattleService_ReconnectBattle_FullMethodName  = "/pb.BattleService/ReconnectBattle"
	BattleService_SyncBattleAction_FullMethodName = "/pb.BattleService/SyncBattleAction"
)

// BattleServiceClient is the client API for BattleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 战斗相关
type BattleServiceClient interface {
	CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*CreateRoomResponse, error)
	JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*JoinRoomResponse, error)
	LeaveRoom(ctx context.Context, in *LeaveRoomRequest, opts ...grpc.CallOption) (*CommonResponse, error)
	StartBattle(ctx context.Context, in *StartBattleRequest, opts ...grpc.CallOption) (*StartBattleResponse, error)
	EndBattle(ctx context.Context, in *EndBattleRequest, opts ...grpc.CallOption) (*EndBattleResponse, error)
	ReconnectBattle(ctx context.Context, in *ReconnectBattleRequest, opts ...grpc.CallOption) (*BattleStateResponse, error)
	SyncBattleAction(ctx context.Context, in *SyncBattleActionRequest, opts ...grpc.CallOption) (*CommonResponse, error)
}

type battleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBattleServiceClient(cc grpc.ClientConnInterface) BattleServiceClient {
	return &battleServiceClient{cc}
}

func (c *battleServiceClient) CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*CreateRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRoomResponse)
	err := c.cc.Invoke(ctx, BattleService_CreateRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*JoinRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinRoomResponse)
	err := c.cc.Invoke(ctx, BattleService_JoinRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) LeaveRoom(ctx context.Context, in *LeaveRoomRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, BattleService_LeaveRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) StartBattle(ctx context.Context, in *StartBattleRequest, opts ...grpc.CallOption) (*StartBattleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartBattleResponse)
	err := c.cc.Invoke(ctx, BattleService_StartBattle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) EndBattle(ctx context.Context, in *EndBattleRequest, opts ...grpc.CallOption) (*EndBattleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndBattleResponse)
	err := c.cc.Invoke(ctx, BattleService_EndBattle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) ReconnectBattle(ctx context.Context, in *ReconnectBattleRequest, opts ...grpc.CallOption) (*BattleStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BattleStateResponse)
	err := c.cc.Invoke(ctx, BattleService_ReconnectBattle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *battleServiceClient) SyncBattleAction(ctx context.Context, in *SyncBattleActionRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, BattleService_SyncBattleAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BattleServiceServer is the server API for BattleService service.
// All implementations must embed UnimplementedBattleServiceServer
// for forward compatibility.
//
// 战斗相关
type BattleServiceServer interface {
	CreateRoom(context.Context, *CreateRoomRequest) (*CreateRoomResponse, error)
	JoinRoom(context.Context, *JoinRoomRequest) (*JoinRoomResponse, error)
	LeaveRoom(context.Context, *LeaveRoomRequest) (*CommonResponse, error)
	StartBattle(context.Context, *StartBattleRequest) (*StartBattleResponse, error)
	EndBattle(context.Context, *EndBattleRequest) (*EndBattleResponse, error)
	ReconnectBattle(context.Context, *ReconnectBattleRequest) (*BattleStateResponse, error)
	SyncBattleAction(context.Context, *SyncBattleActionRequest) (*CommonResponse, error)
	mustEmbedUnimplementedBattleServiceServer()
}

// UnimplementedBattleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBattleServiceServer struct{}

func (UnimplementedBattleServiceServer) CreateRoom(context.Context, *CreateRoomRequest) (*CreateRoomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoom not implemented")
}
func (UnimplementedBattleServiceServer) JoinRoom(context.Context, *JoinRoomRequest) (*JoinRoomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinRoom not implemented")
}
func (UnimplementedBattleServiceServer) LeaveRoom(context.Context, *LeaveRoomRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveRoom not implemented")
}
func (UnimplementedBattleServiceServer) StartBattle(context.Context, *StartBattleRequest) (*StartBattleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBattle not implemented")
}
func (UnimplementedBattleServiceServer) EndBattle(context.Context, *EndBattleRequest) (*EndBattleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndBattle not implemented")
}
func (UnimplementedBattleServiceServer) ReconnectBattle(context.Context, *ReconnectBattleRequest) (*BattleStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReconnectBattle not implemented")
}
func (UnimplementedBattleServiceServer) SyncBattleAction(context.Context, *SyncBattleActionRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncBattleAction not implemented")
}
func (UnimplementedBattleServiceServer) mustEmbedUnimplementedBattleServiceServer() {}
func (UnimplementedBattleServiceServer) testEmbeddedByValue()                       {}

// UnsafeBattleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BattleServiceServer will
// result in compilation errors.
type UnsafeBattleServiceServer interface {
	mustEmbedUnimplementedBattleServiceServer()
}

func RegisterBattleServiceServer(s grpc.ServiceRegistrar, srv BattleServiceServer) {
	// If the following call pancis, it indicates UnimplementedBattleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BattleService_ServiceDesc, srv)
}

func _BattleService_CreateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).CreateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_CreateRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).CreateRoom(ctx, req.(*CreateRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_JoinRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).JoinRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_JoinRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).JoinRoom(ctx, req.(*JoinRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_LeaveRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).LeaveRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_LeaveRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).LeaveRoom(ctx, req.(*LeaveRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_StartBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBattleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).StartBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_StartBattle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).StartBattle(ctx, req.(*StartBattleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_EndBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndBattleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).EndBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_EndBattle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).EndBattle(ctx, req.(*EndBattleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_ReconnectBattle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconnectBattleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).ReconnectBattle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_ReconnectBattle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).ReconnectBattle(ctx, req.(*ReconnectBattleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BattleService_SyncBattleAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncBattleActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleServiceServer).SyncBattleAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleService_SyncBattleAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleServiceServer).SyncBattleAction(ctx, req.(*SyncBattleActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BattleService_ServiceDesc is the grpc.ServiceDesc for BattleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BattleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.BattleService",
	HandlerType: (*BattleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRoom",
			Handler:    _BattleService_CreateRoom_Handler,
		},
		{
			MethodName: "JoinRoom",
			Handler:    _BattleService_JoinRoom_Handler,
		},
		{
			MethodName: "LeaveRoom",
			Handler:    _BattleService_LeaveRoom_Handler,
		},
		{
			MethodName: "StartBattle",
			Handler:    _BattleService_StartBattle_Handler,
		},
		{
			MethodName: "EndBattle",
			Handler:    _BattleService_EndBattle_Handler,
		},
		{
			MethodName: "ReconnectBattle",
			Handler:    _BattleService_ReconnectBattle_Handler,
		},
		{
			MethodName: "SyncBattleAction",
			Handler:    _BattleService_SyncBattleAction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	BagService_GetBagInfo_FullMethodName   = "/pb.BagService/GetBagInfo"
	BagService_UseItem_FullMethodName      = "/pb.BagService/UseItem"
	BagService_DropItem_FullMethodName     = "/pb.BagService/DropItem"
	BagService_CombineItems_FullMethodName = "/pb.BagService/CombineItems"
)

// BagServiceClient is the client API for BagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 背包相关
type BagServiceClient interface {
	GetBagInfo(ctx context.Context, in *GetBagRequest, opts ...grpc.CallOption) (*BagResponse, error)
	UseItem(ctx context.Context, in *UseItemRequest, opts ...grpc.CallOption) (*UseItemResponse, error)
	DropItem(ctx context.Context, in *DropItemRequest, opts ...grpc.CallOption) (*CommonResponse, error)
	CombineItems(ctx context.Context, in *CombineItemsRequest, opts ...grpc.CallOption) (*CombineItemsResponse, error)
}

type bagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBagServiceClient(cc grpc.ClientConnInterface) BagServiceClient {
	return &bagServiceClient{cc}
}

func (c *bagServiceClient) GetBagInfo(ctx context.Context, in *GetBagRequest, opts ...grpc.CallOption) (*BagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BagResponse)
	err := c.cc.Invoke(ctx, BagService_GetBagInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bagServiceClient) UseItem(ctx context.Context, in *UseItemRequest, opts ...grpc.CallOption) (*UseItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UseItemResponse)
	err := c.cc.Invoke(ctx, BagService_UseItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bagServiceClient) DropItem(ctx context.Context, in *DropItemRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, BagService_DropItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bagServiceClient) CombineItems(ctx context.Context, in *CombineItemsRequest, opts ...grpc.CallOption) (*CombineItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CombineItemsResponse)
	err := c.cc.Invoke(ctx, BagService_CombineItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BagServiceServer is the server API for BagService service.
// All implementations must embed UnimplementedBagServiceServer
// for forward compatibility.
//
// 背包相关
type BagServiceServer interface {
	GetBagInfo(context.Context, *GetBagRequest) (*BagResponse, error)
	UseItem(context.Context, *UseItemRequest) (*UseItemResponse, error)
	DropItem(context.Context, *DropItemRequest) (*CommonResponse, error)
	CombineItems(context.Context, *CombineItemsRequest) (*CombineItemsResponse, error)
	mustEmbedUnimplementedBagServiceServer()
}

// UnimplementedBagServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBagServiceServer struct{}

func (UnimplementedBagServiceServer) GetBagInfo(context.Context, *GetBagRequest) (*BagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBagInfo not implemented")
}
func (UnimplementedBagServiceServer) UseItem(context.Context, *UseItemRequest) (*UseItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseItem not implemented")
}
func (UnimplementedBagServiceServer) DropItem(context.Context, *DropItemRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropItem not implemented")
}
func (UnimplementedBagServiceServer) CombineItems(context.Context, *CombineItemsRequest) (*CombineItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CombineItems not implemented")
}
func (UnimplementedBagServiceServer) mustEmbedUnimplementedBagServiceServer() {}
func (UnimplementedBagServiceServer) testEmbeddedByValue()                    {}

// UnsafeBagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BagServiceServer will
// result in compilation errors.
type UnsafeBagServiceServer interface {
	mustEmbedUnimplementedBagServiceServer()
}

func RegisterBagServiceServer(s grpc.ServiceRegistrar, srv BagServiceServer) {
	// If the following call pancis, it indicates UnimplementedBagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BagService_ServiceDesc, srv)
}

func _BagService_GetBagInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BagServiceServer).GetBagInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BagService_GetBagInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BagServiceServer).GetBagInfo(ctx, req.(*GetBagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BagService_UseItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BagServiceServer).UseItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BagService_UseItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BagServiceServer).UseItem(ctx, req.(*UseItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BagService_DropItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BagServiceServer).DropItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BagService_DropItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BagServiceServer).DropItem(ctx, req.(*DropItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BagService_CombineItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombineItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BagServiceServer).CombineItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BagService_CombineItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BagServiceServer).CombineItems(ctx, req.(*CombineItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BagService_ServiceDesc is the grpc.ServiceDesc for BagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.BagService",
	HandlerType: (*BagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBagInfo",
			Handler:    _BagService_GetBagInfo_Handler,
		},
		{
			MethodName: "UseItem",
			Handler:    _BagService_UseItem_Handler,
		},
		{
			MethodName: "DropItem",
			Handler:    _BagService_DropItem_Handler,
		},
		{
			MethodName: "CombineItems",
			Handler:    _BagService_CombineItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	MailService_GetMailList_FullMethodName           = "/pb.MailService/GetMailList"
	MailService_GetMailDetail_FullMethodName         = "/pb.MailService/GetMailDetail"
	MailService_ReceiveMailAttachment_FullMethodName = "/pb.MailService/ReceiveMailAttachment"
	MailService_DeleteMail_FullMethodName            = "/pb.MailService/DeleteMail"
)

// MailServiceClient is the client API for MailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 邮箱相关
type MailServiceClient interface {
	GetMailList(ctx context.Context, in *GetMailListRequest, opts ...grpc.CallOption) (*GetMailListResponse, error)
	GetMailDetail(ctx context.Context, in *GetMailDetailRequest, opts ...grpc.CallOption) (*GetMailDetailResponse, error)
	ReceiveMailAttachment(ctx context.Context, in *ReceiveMailAttachmentRequest, opts ...grpc.CallOption) (*ReceiveMailAttachmentResponse, error)
	DeleteMail(ctx context.Context, in *DeleteMailRequest, opts ...grpc.CallOption) (*CommonResponse, error)
}

type mailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMailServiceClient(cc grpc.ClientConnInterface) MailServiceClient {
	return &mailServiceClient{cc}
}

func (c *mailServiceClient) GetMailList(ctx context.Context, in *GetMailListRequest, opts ...grpc.CallOption) (*GetMailListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMailListResponse)
	err := c.cc.Invoke(ctx, MailService_GetMailList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) GetMailDetail(ctx context.Context, in *GetMailDetailRequest, opts ...grpc.CallOption) (*GetMailDetailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMailDetailResponse)
	err := c.cc.Invoke(ctx, MailService_GetMailDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) ReceiveMailAttachment(ctx context.Context, in *ReceiveMailAttachmentRequest, opts ...grpc.CallOption) (*ReceiveMailAttachmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReceiveMailAttachmentResponse)
	err := c.cc.Invoke(ctx, MailService_ReceiveMailAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailServiceClient) DeleteMail(ctx context.Context, in *DeleteMailRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, MailService_DeleteMail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MailServiceServer is the server API for MailService service.
// All implementations must embed UnimplementedMailServiceServer
// for forward compatibility.
//
// 邮箱相关
type MailServiceServer interface {
	GetMailList(context.Context, *GetMailListRequest) (*GetMailListResponse, error)
	GetMailDetail(context.Context, *GetMailDetailRequest) (*GetMailDetailResponse, error)
	ReceiveMailAttachment(context.Context, *ReceiveMailAttachmentRequest) (*ReceiveMailAttachmentResponse, error)
	DeleteMail(context.Context, *DeleteMailRequest) (*CommonResponse, error)
	mustEmbedUnimplementedMailServiceServer()
}

// UnimplementedMailServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMailServiceServer struct{}

func (UnimplementedMailServiceServer) GetMailList(context.Context, *GetMailListRequest) (*GetMailListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMailList not implemented")
}
func (UnimplementedMailServiceServer) GetMailDetail(context.Context, *GetMailDetailRequest) (*GetMailDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMailDetail not implemented")
}
func (UnimplementedMailServiceServer) ReceiveMailAttachment(context.Context, *ReceiveMailAttachmentRequest) (*ReceiveMailAttachmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveMailAttachment not implemented")
}
func (UnimplementedMailServiceServer) DeleteMail(context.Context, *DeleteMailRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMail not implemented")
}
func (UnimplementedMailServiceServer) mustEmbedUnimplementedMailServiceServer() {}
func (UnimplementedMailServiceServer) testEmbeddedByValue()                     {}

// UnsafeMailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MailServiceServer will
// result in compilation errors.
type UnsafeMailServiceServer interface {
	mustEmbedUnimplementedMailServiceServer()
}

func RegisterMailServiceServer(s grpc.ServiceRegistrar, srv MailServiceServer) {
	// If the following call pancis, it indicates UnimplementedMailServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MailService_ServiceDesc, srv)
}

func _MailService_GetMailList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMailListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).GetMailList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_GetMailList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).GetMailList(ctx, req.(*GetMailListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_GetMailDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMailDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).GetMailDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_GetMailDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).GetMailDetail(ctx, req.(*GetMailDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_ReceiveMailAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveMailAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).ReceiveMailAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_ReceiveMailAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).ReceiveMailAttachment(ctx, req.(*ReceiveMailAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MailService_DeleteMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServiceServer).DeleteMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MailService_DeleteMail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServiceServer).DeleteMail(ctx, req.(*DeleteMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MailService_ServiceDesc is the grpc.ServiceDesc for MailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MailService",
	HandlerType: (*MailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMailList",
			Handler:    _MailService_GetMailList_Handler,
		},
		{
			MethodName: "GetMailDetail",
			Handler:    _MailService_GetMailDetail_Handler,
		},
		{
			MethodName: "ReceiveMailAttachment",
			Handler:    _MailService_ReceiveMailAttachment_Handler,
		},
		{
			MethodName: "DeleteMail",
			Handler:    _MailService_DeleteMail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	TaskService_GetTaskList_FullMethodName   = "/pb.TaskService/GetTaskList"
	TaskService_GetTaskDetail_FullMethodName = "/pb.TaskService/GetTaskDetail"
	TaskService_AcceptTask_FullMethodName    = "/pb.TaskService/AcceptTask"
	TaskService_SubmitTask_FullMethodName    = "/pb.TaskService/SubmitTask"
	TaskService_GiveUpTask_FullMethodName    = "/pb.TaskService/GiveUpTask"
)

// TaskServiceClient is the client API for TaskService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 任务相关
type TaskServiceClient interface {
	GetTaskList(ctx context.Context, in *GetTaskListRequest, opts ...grpc.CallOption) (*GetTaskListResponse, error)
	GetTaskDetail(ctx context.Context, in *GetTaskDetailRequest, opts ...grpc.CallOption) (*GetTaskDetailResponse, error)
	AcceptTask(ctx context.Context, in *AcceptTaskRequest, opts ...grpc.CallOption) (*CommonResponse, error)
	SubmitTask(ctx context.Context, in *SubmitTaskRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	GiveUpTask(ctx context.Context, in *GiveUpTaskRequest, opts ...grpc.CallOption) (*CommonResponse, error)
}

type taskServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskServiceClient(cc grpc.ClientConnInterface) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) GetTaskList(ctx context.Context, in *GetTaskListRequest, opts ...grpc.CallOption) (*GetTaskListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTaskListResponse)
	err := c.cc.Invoke(ctx, TaskService_GetTaskList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) GetTaskDetail(ctx context.Context, in *GetTaskDetailRequest, opts ...grpc.CallOption) (*GetTaskDetailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTaskDetailResponse)
	err := c.cc.Invoke(ctx, TaskService_GetTaskDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) AcceptTask(ctx context.Context, in *AcceptTaskRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, TaskService_AcceptTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) SubmitTask(ctx context.Context, in *SubmitTaskRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, TaskService_SubmitTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) GiveUpTask(ctx context.Context, in *GiveUpTaskRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, TaskService_GiveUpTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskServiceServer is the server API for TaskService service.
// All implementations must embed UnimplementedTaskServiceServer
// for forward compatibility.
//
// 任务相关
type TaskServiceServer interface {
	GetTaskList(context.Context, *GetTaskListRequest) (*GetTaskListResponse, error)
	GetTaskDetail(context.Context, *GetTaskDetailRequest) (*GetTaskDetailResponse, error)
	AcceptTask(context.Context, *AcceptTaskRequest) (*CommonResponse, error)
	SubmitTask(context.Context, *SubmitTaskRequest) (*SubmitTaskResponse, error)
	GiveUpTask(context.Context, *GiveUpTaskRequest) (*CommonResponse, error)
	mustEmbedUnimplementedTaskServiceServer()
}

// UnimplementedTaskServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskServiceServer struct{}

func (UnimplementedTaskServiceServer) GetTaskList(context.Context, *GetTaskListRequest) (*GetTaskListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskList not implemented")
}
func (UnimplementedTaskServiceServer) GetTaskDetail(context.Context, *GetTaskDetailRequest) (*GetTaskDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskDetail not implemented")
}
func (UnimplementedTaskServiceServer) AcceptTask(context.Context, *AcceptTaskRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptTask not implemented")
}
func (UnimplementedTaskServiceServer) SubmitTask(context.Context, *SubmitTaskRequest) (*SubmitTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTask not implemented")
}
func (UnimplementedTaskServiceServer) GiveUpTask(context.Context, *GiveUpTaskRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GiveUpTask not implemented")
}
func (UnimplementedTaskServiceServer) mustEmbedUnimplementedTaskServiceServer() {}
func (UnimplementedTaskServiceServer) testEmbeddedByValue()                     {}

// UnsafeTaskServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskServiceServer will
// result in compilation errors.
type UnsafeTaskServiceServer interface {
	mustEmbedUnimplementedTaskServiceServer()
}

func RegisterTaskServiceServer(s grpc.ServiceRegistrar, srv TaskServiceServer) {
	// If the following call pancis, it indicates UnimplementedTaskServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskService_ServiceDesc, srv)
}

func _TaskService_GetTaskList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetTaskList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_GetTaskList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetTaskList(ctx, req.(*GetTaskListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_GetTaskDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetTaskDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_GetTaskDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetTaskDetail(ctx, req.(*GetTaskDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_AcceptTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).AcceptTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_AcceptTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).AcceptTask(ctx, req.(*AcceptTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_SubmitTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).SubmitTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_SubmitTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).SubmitTask(ctx, req.(*SubmitTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_GiveUpTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GiveUpTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GiveUpTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskService_GiveUpTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GiveUpTask(ctx, req.(*GiveUpTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskService_ServiceDesc is the grpc.ServiceDesc for TaskService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTaskList",
			Handler:    _TaskService_GetTaskList_Handler,
		},
		{
			MethodName: "GetTaskDetail",
			Handler:    _TaskService_GetTaskDetail_Handler,
		},
		{
			MethodName: "AcceptTask",
			Handler:    _TaskService_AcceptTask_Handler,
		},
		{
			MethodName: "SubmitTask",
			Handler:    _TaskService_SubmitTask_Handler,
		},
		{
			MethodName: "GiveUpTask",
			Handler:    _TaskService_GiveUpTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	ShopService_GetShopList_FullMethodName     = "/pb.ShopService/GetShopList"
	ShopService_BuyItem_FullMethodName         = "/pb.ShopService/BuyItem"
	ShopService_GetDiscountInfo_FullMethodName = "/pb.ShopService/GetDiscountInfo"
)

// ShopServiceClient is the client API for ShopService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 商场相关
type ShopServiceClient interface {
	GetShopList(ctx context.Context, in *GetShopListRequest, opts ...grpc.CallOption) (*GetShopListResponse, error)
	BuyItem(ctx context.Context, in *BuyItemRequest, opts ...grpc.CallOption) (*BuyItemResponse, error)
	GetDiscountInfo(ctx context.Context, in *GetDiscountInfoRequest, opts ...grpc.CallOption) (*GetDiscountInfoResponse, error)
}

type shopServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewShopServiceClient(cc grpc.ClientConnInterface) ShopServiceClient {
	return &shopServiceClient{cc}
}

func (c *shopServiceClient) GetShopList(ctx context.Context, in *GetShopListRequest, opts ...grpc.CallOption) (*GetShopListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetShopListResponse)
	err := c.cc.Invoke(ctx, ShopService_GetShopList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) BuyItem(ctx context.Context, in *BuyItemRequest, opts ...grpc.CallOption) (*BuyItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyItemResponse)
	err := c.cc.Invoke(ctx, ShopService_BuyItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) GetDiscountInfo(ctx context.Context, in *GetDiscountInfoRequest, opts ...grpc.CallOption) (*GetDiscountInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDiscountInfoResponse)
	err := c.cc.Invoke(ctx, ShopService_GetDiscountInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShopServiceServer is the server API for ShopService service.
// All implementations must embed UnimplementedShopServiceServer
// for forward compatibility.
//
// 商场相关
type ShopServiceServer interface {
	GetShopList(context.Context, *GetShopListRequest) (*GetShopListResponse, error)
	BuyItem(context.Context, *BuyItemRequest) (*BuyItemResponse, error)
	GetDiscountInfo(context.Context, *GetDiscountInfoRequest) (*GetDiscountInfoResponse, error)
	mustEmbedUnimplementedShopServiceServer()
}

// UnimplementedShopServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShopServiceServer struct{}

func (UnimplementedShopServiceServer) GetShopList(context.Context, *GetShopListRequest) (*GetShopListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShopList not implemented")
}
func (UnimplementedShopServiceServer) BuyItem(context.Context, *BuyItemRequest) (*BuyItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyItem not implemented")
}
func (UnimplementedShopServiceServer) GetDiscountInfo(context.Context, *GetDiscountInfoRequest) (*GetDiscountInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiscountInfo not implemented")
}
func (UnimplementedShopServiceServer) mustEmbedUnimplementedShopServiceServer() {}
func (UnimplementedShopServiceServer) testEmbeddedByValue()                     {}

// UnsafeShopServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShopServiceServer will
// result in compilation errors.
type UnsafeShopServiceServer interface {
	mustEmbedUnimplementedShopServiceServer()
}

func RegisterShopServiceServer(s grpc.ServiceRegistrar, srv ShopServiceServer) {
	// If the following call pancis, it indicates UnimplementedShopServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ShopService_ServiceDesc, srv)
}

func _ShopService_GetShopList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShopListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).GetShopList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_GetShopList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).GetShopList(ctx, req.(*GetShopListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_BuyItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).BuyItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_BuyItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).BuyItem(ctx, req.(*BuyItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_GetDiscountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiscountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).GetDiscountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_GetDiscountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).GetDiscountInfo(ctx, req.(*GetDiscountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShopService_ServiceDesc is the grpc.ServiceDesc for ShopService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShopService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ShopService",
	HandlerType: (*ShopServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetShopList",
			Handler:    _ShopService_GetShopList_Handler,
		},
		{
			MethodName: "BuyItem",
			Handler:    _ShopService_BuyItem_Handler,
		},
		{
			MethodName: "GetDiscountInfo",
			Handler:    _ShopService_GetDiscountInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	RecordService_GetPlayerRecords_FullMethodName = "/pb.RecordService/GetPlayerRecords"
	RecordService_GetBattleDetail_FullMethodName  = "/pb.RecordService/GetBattleDetail"
)

// RecordServiceClient is the client API for RecordService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 战绩相关
type RecordServiceClient interface {
	GetPlayerRecords(ctx context.Context, in *GetPlayerRecordsRequest, opts ...grpc.CallOption) (*GetPlayerRecordsResponse, error)
	GetBattleDetail(ctx context.Context, in *GetBattleDetailRequest, opts ...grpc.CallOption) (*GetBattleDetailResponse, error)
}

type recordServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRecordServiceClient(cc grpc.ClientConnInterface) RecordServiceClient {
	return &recordServiceClient{cc}
}

func (c *recordServiceClient) GetPlayerRecords(ctx context.Context, in *GetPlayerRecordsRequest, opts ...grpc.CallOption) (*GetPlayerRecordsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlayerRecordsResponse)
	err := c.cc.Invoke(ctx, RecordService_GetPlayerRecords_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *recordServiceClient) GetBattleDetail(ctx context.Context, in *GetBattleDetailRequest, opts ...grpc.CallOption) (*GetBattleDetailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBattleDetailResponse)
	err := c.cc.Invoke(ctx, RecordService_GetBattleDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RecordServiceServer is the server API for RecordService service.
// All implementations must embed UnimplementedRecordServiceServer
// for forward compatibility.
//
// 战绩相关
type RecordServiceServer interface {
	GetPlayerRecords(context.Context, *GetPlayerRecordsRequest) (*GetPlayerRecordsResponse, error)
	GetBattleDetail(context.Context, *GetBattleDetailRequest) (*GetBattleDetailResponse, error)
	mustEmbedUnimplementedRecordServiceServer()
}

// UnimplementedRecordServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRecordServiceServer struct{}

func (UnimplementedRecordServiceServer) GetPlayerRecords(context.Context, *GetPlayerRecordsRequest) (*GetPlayerRecordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlayerRecords not implemented")
}
func (UnimplementedRecordServiceServer) GetBattleDetail(context.Context, *GetBattleDetailRequest) (*GetBattleDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBattleDetail not implemented")
}
func (UnimplementedRecordServiceServer) mustEmbedUnimplementedRecordServiceServer() {}
func (UnimplementedRecordServiceServer) testEmbeddedByValue()                       {}

// UnsafeRecordServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RecordServiceServer will
// result in compilation errors.
type UnsafeRecordServiceServer interface {
	mustEmbedUnimplementedRecordServiceServer()
}

func RegisterRecordServiceServer(s grpc.ServiceRegistrar, srv RecordServiceServer) {
	// If the following call pancis, it indicates UnimplementedRecordServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RecordService_ServiceDesc, srv)
}

func _RecordService_GetPlayerRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlayerRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecordServiceServer).GetPlayerRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RecordService_GetPlayerRecords_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecordServiceServer).GetPlayerRecords(ctx, req.(*GetPlayerRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RecordService_GetBattleDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBattleDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecordServiceServer).GetBattleDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RecordService_GetBattleDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecordServiceServer).GetBattleDetail(ctx, req.(*GetBattleDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RecordService_ServiceDesc is the grpc.ServiceDesc for RecordService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RecordService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RecordService",
	HandlerType: (*RecordServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlayerRecords",
			Handler:    _RecordService_GetPlayerRecords_Handler,
		},
		{
			MethodName: "GetBattleDetail",
			Handler:    _RecordService_GetBattleDetail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	RankingService_GetRankingList_FullMethodName = "/pb.RankingService/GetRankingList"
	RankingService_GetPlayerRank_FullMethodName  = "/pb.RankingService/GetPlayerRank"
)

// RankingServiceClient is the client API for RankingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 排行榜相关
type RankingServiceClient interface {
	GetRankingList(ctx context.Context, in *GetRankingListRequest, opts ...grpc.CallOption) (*GetRankingListResponse, error)
	GetPlayerRank(ctx context.Context, in *GetPlayerRankRequest, opts ...grpc.CallOption) (*GetPlayerRankResponse, error)
}

type rankingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRankingServiceClient(cc grpc.ClientConnInterface) RankingServiceClient {
	return &rankingServiceClient{cc}
}

func (c *rankingServiceClient) GetRankingList(ctx context.Context, in *GetRankingListRequest, opts ...grpc.CallOption) (*GetRankingListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRankingListResponse)
	err := c.cc.Invoke(ctx, RankingService_GetRankingList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rankingServiceClient) GetPlayerRank(ctx context.Context, in *GetPlayerRankRequest, opts ...grpc.CallOption) (*GetPlayerRankResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlayerRankResponse)
	err := c.cc.Invoke(ctx, RankingService_GetPlayerRank_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RankingServiceServer is the server API for RankingService service.
// All implementations must embed UnimplementedRankingServiceServer
// for forward compatibility.
//
// 排行榜相关
type RankingServiceServer interface {
	GetRankingList(context.Context, *GetRankingListRequest) (*GetRankingListResponse, error)
	GetPlayerRank(context.Context, *GetPlayerRankRequest) (*GetPlayerRankResponse, error)
	mustEmbedUnimplementedRankingServiceServer()
}

// UnimplementedRankingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRankingServiceServer struct{}

func (UnimplementedRankingServiceServer) GetRankingList(context.Context, *GetRankingListRequest) (*GetRankingListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRankingList not implemented")
}
func (UnimplementedRankingServiceServer) GetPlayerRank(context.Context, *GetPlayerRankRequest) (*GetPlayerRankResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlayerRank not implemented")
}
func (UnimplementedRankingServiceServer) mustEmbedUnimplementedRankingServiceServer() {}
func (UnimplementedRankingServiceServer) testEmbeddedByValue()                        {}

// UnsafeRankingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RankingServiceServer will
// result in compilation errors.
type UnsafeRankingServiceServer interface {
	mustEmbedUnimplementedRankingServiceServer()
}

func RegisterRankingServiceServer(s grpc.ServiceRegistrar, srv RankingServiceServer) {
	// If the following call pancis, it indicates UnimplementedRankingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RankingService_ServiceDesc, srv)
}

func _RankingService_GetRankingList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRankingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RankingServiceServer).GetRankingList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RankingService_GetRankingList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RankingServiceServer).GetRankingList(ctx, req.(*GetRankingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RankingService_GetPlayerRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlayerRankRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RankingServiceServer).GetPlayerRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RankingService_GetPlayerRank_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RankingServiceServer).GetPlayerRank(ctx, req.(*GetPlayerRankRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RankingService_ServiceDesc is the grpc.ServiceDesc for RankingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RankingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RankingService",
	HandlerType: (*RankingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRankingList",
			Handler:    _RankingService_GetRankingList_Handler,
		},
		{
			MethodName: "GetPlayerRank",
			Handler:    _RankingService_GetPlayerRank_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}

const (
	BattleDataProcessService_ProcessBattleData_FullMethodName = "/pb.BattleDataProcessService/ProcessBattleData"
)

// BattleDataProcessServiceClient is the client API for BattleDataProcessService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 战斗数据处理相关（内部服务）
type BattleDataProcessServiceClient interface {
	ProcessBattleData(ctx context.Context, in *ProcessBattleDataRequest, opts ...grpc.CallOption) (*CommonResponse, error)
}

type battleDataProcessServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBattleDataProcessServiceClient(cc grpc.ClientConnInterface) BattleDataProcessServiceClient {
	return &battleDataProcessServiceClient{cc}
}

func (c *battleDataProcessServiceClient) ProcessBattleData(ctx context.Context, in *ProcessBattleDataRequest, opts ...grpc.CallOption) (*CommonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommonResponse)
	err := c.cc.Invoke(ctx, BattleDataProcessService_ProcessBattleData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BattleDataProcessServiceServer is the server API for BattleDataProcessService service.
// All implementations must embed UnimplementedBattleDataProcessServiceServer
// for forward compatibility.
//
// 战斗数据处理相关（内部服务）
type BattleDataProcessServiceServer interface {
	ProcessBattleData(context.Context, *ProcessBattleDataRequest) (*CommonResponse, error)
	mustEmbedUnimplementedBattleDataProcessServiceServer()
}

// UnimplementedBattleDataProcessServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBattleDataProcessServiceServer struct{}

func (UnimplementedBattleDataProcessServiceServer) ProcessBattleData(context.Context, *ProcessBattleDataRequest) (*CommonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessBattleData not implemented")
}
func (UnimplementedBattleDataProcessServiceServer) mustEmbedUnimplementedBattleDataProcessServiceServer() {
}
func (UnimplementedBattleDataProcessServiceServer) testEmbeddedByValue() {}

// UnsafeBattleDataProcessServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BattleDataProcessServiceServer will
// result in compilation errors.
type UnsafeBattleDataProcessServiceServer interface {
	mustEmbedUnimplementedBattleDataProcessServiceServer()
}

func RegisterBattleDataProcessServiceServer(s grpc.ServiceRegistrar, srv BattleDataProcessServiceServer) {
	// If the following call pancis, it indicates UnimplementedBattleDataProcessServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BattleDataProcessService_ServiceDesc, srv)
}

func _BattleDataProcessService_ProcessBattleData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessBattleDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BattleDataProcessServiceServer).ProcessBattleData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BattleDataProcessService_ProcessBattleData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BattleDataProcessServiceServer).ProcessBattleData(ctx, req.(*ProcessBattleDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BattleDataProcessService_ServiceDesc is the grpc.ServiceDesc for BattleDataProcessService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BattleDataProcessService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.BattleDataProcessService",
	HandlerType: (*BattleDataProcessServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessBattleData",
			Handler:    _BattleDataProcessService_ProcessBattleData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game.proto",
}
